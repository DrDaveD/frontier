<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Frontier Client Usage</title>
  </head>

  <body>
    <h1>Frontier Client Usage</h1>



<h2>Building C/C++ Client Libraries and Test Executables </h2>
    
   
<ul>
<li>The latest Frontier client source code can be downloaded from <a
href="http://edge.fnal.gov:8888/frontier/">http://edge.fnal.gov:8888/frontier/</a>.

<li>The distribution contains everything necessary to build C/C++ Frontier
clients, including a recent version of expat libraries.

<li>To build the client libraries and test executables one can simply execute
<em>make</em> in the client source directory.

<li>These make command line variables can be defined to select non-default
libraries for support packages:
  <ul>
  <li>
  EXPAT_DIR - expat (overrides included library)
  <li>
  ZLIB_DIR - zlib (overrides system library)
  <li>
  OPENSSL_DIR - openssl (overrides system library)
  </ul>

<li>To prepare source code distribution file: make src-dist (will create tar
file in the client/tmp directory)

<li>To prepare library distribution file: make dist (will create tar file in
the client/tmp directory)

<li> Client release notes have been maintained in the file <em>RELEASE_NOTES</em>. 

</ul>

<h2>Client configuration</h2>

Frontier client configuration can can come from a complex server
connection string made up of multiple keyword=value pairs enclosed in
parentheses.  For example:
<pre>
    (serverurl=http://cmsfrontier.cern.ch:8000)(retrieveziplevel=0)...
</pre>
If there are any parentheses in a server connection string, anything
outside of parentheses is ignored (for example, it is often convenient
to precede the string with http:// to pretend the whole string is a
server url).  If any of the configuration items are missing from the
server connection string, they can also be read from environment
variables.  These are the connection string keywords and corresponding
environment variables:
<ul>
<li>
serverurl - server of the form http://host:port/servlet (:port is
optional and defaults to 80).  Multiple serverurl keywords may be
supplied and they will be tried in the order listed.  Environment
variables FRONTIER_SERVER and FRONTIER_SERVER[123456] can add
additional servers, up to a maximum of 6.  Each server string is also
recursively parsed for parenthesized keywords.
<li>
proxyurl - proxy of the form http://host:port.  Multiple proxyurl
keywords may be supplied and they will be tried in the order listed.
Environment variables FRONTIER_PROXY and FRONTIER_PROXY[1234] can add
additional proxies, up to a maximum of 4.
<li>
logicalserverurl - logical server of the form http://logical_name
which, when encountered in a later connection as a server name, will
be replaced by the entire rest of the complex connection string that
the logicalserverurl keyword came from.  If logicalserverurl is not
present in the connection string, it may come from environment variable
FRONTIER_LOGICALSERVER and then its replacement string comes from
FRONTIER_PHYSICALSERVERS.
<li>
retrieveziplevel - zip level of retrieved data, from 0 for none to
1 for fast to 9 for best.  If not present, may come from environment
variable FRONTIER_RETRIEVEZIPLEVEL.  Default 5.
<li>
connecttimeoutsecs - number of seconds before timeout on a server or
proxy connection.  If not present, may come from environment variable
FRONTIER_CONNECTTIMEOUTSECS.  Default 5.
<li>
readtimeoutsecs - number of seconds before timeout on a read from a
server or proxy.  If not present, may come from environment variable
FRONTIER_READTIMEOUTSECS.  Default 10.
<li>
writetimeoutsecs - number of seconds before timeout on a write to a
server or proxy.  If not present, may come from environment variable
FRONTIER_WRITETIMEOUTSECS.  Default 5.
<li>
forcereload - value of "short" forces an immediate cache refresh
on all short time-to-live queries (those indicated by setReload API),
and a value of "long"  forces an immediate refresh on all queries.
If not present, may come from environment variable 
FRONTIER_FORCERELOAD.  Default "none".
</ul>

<p>
These may only come from environment variables:
<ul>
<li>
FRONTIER_LOG_LEVEL - set logging level
<ul>
<li>
nolog - no log output (default)
<li>
error - log errors
<li>
warning - log errors and warnings (which mainly have to do with non-fatal
connection problems and retries)
<li>
debug - log errors, warnings, and verbose debug messages
<li>
</ul>
FRONTIER_LOG_FILE - filename to write log messages to instead of stdout
</ul>

<p>
Note that isn't part of frontier client but may be useful information
to some readers: in CMS, a long connection string is constructed from
the frontier-connect portion of site-local-config.xml in
$CMS_PATH/SITECONF/local/JobConfig.  Blanks and quotes are removed
from that and they're converted into the parenthesized form above,
plus a (logicalserverurl=http://cms_conditions_data) is added so that
form can be used a shortcut.


<h2>C++ Test Client Usage</h2>

<ul>

<li>
Simple C++ test executable is fn-req (source file <em>test-req.cc</em>).
Here is an example of a query against the Frontier server running on
edge.fnal.gov:

<pre>

$ echo $FRONTIER_SERVER1
http://edge.fnal.gov:8000/FrontierCMS
$ echo $FRONTIER_PROXY1
http://cmssrv11.fnal.gov:3128
$ echo $FRONTIER_LOG_LEVEL
debug
$ cat test_query.sql
SELECT COLUMN_NAME FROM RATNIKOV.POOL_OR_MAPPING_COLUMNS WHERE VERSION='automatic_default_for_HcalPedestals' ORDER BY POSITION
$ ./fn-req -f test_query.sql
Entered:
SELECT COLUMN_NAME FROM RATNIKOV.POOL_OR_MAPPING_COLUMNS WHERE VERSION='automatic_default_for_HcalPedestals' ORDER BY POSITION

Param [eNoly7EKwjAQANC9X3FbN--AIbanDSa5cIkVpyO0KQiRQpv.v4L7ewENdhE6Mg-rxCmLcGWywCo6fafx5ImMEItV3mt3k78M8ByQEUbkoMmd23TU9ZPqe5I5L.koVZZ1k2FKxec57zWVvQXiHhkuL-AUdPy9pvkC3QIn-Q__]
...

Object fields:
1 COLUMN_NAME VARCHAR2

Result contains 0 objects.
'ID'
'POS'
'POS'
'MITEMS_HCALPEDESTAL_MID'
'MITEMS_HCALPEDESTAL_MVALUE2'
'MITEMS_HCALPEDESTAL_MVALUE4'
'MSORTED'
'MITEMS_HCALPEDESTAL_MVALUE3'
'MITEMS_HCALPEDESTAL_MVALUE1'
'ID_ID'
'ID_ID'
$

</pre>

</ul>

<h2> Writing C++ Clients</h2>

<ul>

<li> The C++ classes which handle communication with Frontier servers
and proxies are the <em>Connection</em> and <em>Session</em> classes.
A Connection object can be used to hold a connection open for multiple
queries, and queries are done one per Session object.  Here is an
example of creating an instance of each:

<pre>

#include <string>
#include <list>
#include "frontier_client/frontier-cpp.h"
...

std::list<std::string> serverList;
serverList.push_back("http://edge.fnal.gov:8000/FrontierCMS");
std::list<std::string> proxyList;
frontier::Connection connection(serverList, proxyList);
frontier::Session session(&connection);
...

</pre>
  
Note that the Connection object created via the default class
constructor will be configured using the above mentioned environment
variables (FRONTIER_SERVER[1,2,3,4], FRONTIER_PROXY[1,2,3,4]).

<p>
<li>Frontier requests are handled via the <em>Request</em> class:

<pre>
...
std::string sql("select 1 from dual");
std::string parameter1 = frontier::Request::encodeParam(sql);

frontier::Request request("FrontierTestRequest:1", frontier::BLOB);
request.addKey("p1", parameter1);

std::vector<const frontier::Request*> requestVector;
requestVector.push_back(&request);

</pre>

<li>The Session object retrieves request data from the Frontier
server, and provides an iterator for going over the returned records:

<pre>
    
// Retrieve data.
session.getData(requestVector);
session.setCurrentLoad(1);

// Go over the object fields (metaData consists of one record with field names).
int field_num=0;
std::cout << "Object fields:" << std::endl;
std::string name, type;
session.next();
while(!session.isEOR()) {
  session.assignString(&name);
  session.assignString(&type);
  ++field_num;
  std::cout << field_num << " " << (name) << " " << (type) << std::endl;
}

// Go over the actual records and extract them according to their type.
std::cout << " \nResult contains "<< session.getNumberOfRecords() <<" objects.\n";
frontier::AnyData ad;
std::string stringBuf;
std::string *vs = &stringBuf;
while(session.next()) {
  for(int k=0;k<field_num;k++) {
    session.getAnyData(&ad);
    switch(ad.type()) {
      case frontier::BLOB_TYPE_INT4:
        int vi = ad.getInt();
        std::cout << vi;
        break;
      case frontier::BLOB_TYPE_INT8:
        long long vl = ad.getLongLong();
        std::cout << vl;
        break;
      case frontier::BLOB_TYPE_FLOAT:
        float vf = ad.getFloat();
        std::cout << vf;
        break;
      case frontier::BLOB_TYPE_DOUBLE:
        double vd = ad.getDouble();
        std::cout << vd;
        break;
      case frontier::BLOB_TYPE_TIME:
        long long vl=ad.getLongLong();
        std::cout<<vl;
        break;
      case frontier::BLOB_TYPE_ARRAY_BYTE:
        ad.assignString(vs);
        if(vs->size() != 0) {
          std::cout<<"NULL";
        }
        else {
          str_escape_quota(vs);
          std::cout << '\'' << (*vs) <<'\'';
        }
        break;
      default:
        std::cout<<"Error: unknown typeId "<<((int)(ad.type()))<<"\n";
        exit(1);
    }
  }
}

</pre>

<li> All exceptions that can be thrown from the Frontier libraries
inherit from the <em>FrontierException</em> class. Therefore, one
should be able to enclose all Frontier calls into try/catch block as
follows:

<pre>
try {
  // Construct frontier objects and do something.
}
catch(const frontier::FrontierException& e) {
  std::cout << "Frontier exception caught: " << e.what() << std::endl;
  // Handle generic error.
}

</pre>

All frontier exceptions (e.g., <em>ConfigurationError</em>,
<em>InvalidArgument</em>, <em>NetworkProblem</em>, etc.)  are listed
in the <em>include/frontier_client/FrontierException.hpp</em> file.

<p>
<li> A working example of a frontier C++ client can be found in the file
<em>test-req.cc</em> in the source code distribution.

</ul>




<h2>Python Client Usage</h2>

<ul>
<li>
Simple python frontier client <em> fnget.py</em> can be found in the
frontier/client directory. 

<li>
Example usage: 

<pre>

$ ./fnget.py --url=http://edge.fnal.gov:8000/FrontierCMS/Frontier --sql="SELECT COLUMN_NAME FROM RATNIKOV.POOL_OR_MAPPING_COLUMNS WHERE VERSION='automatic_default_for_HcalPedestals' ORDER BY POSITION"
Using Frontier URL:  http://edge.fnal.gov:8000/FrontierCMS/Frontier
Query:  SELECT COLUMN_NAME FROM RATNIKOV.POOL_OR_MAPPING_COLUMNS WHERE VERSION='automatic_default_for_HcalPedestals' ORDER BY POSITION
Decode results:  True
Refresh cache:  False

Frontier Request:
http://edge.fnal.gov:8000/FrontierCMS/Frontier?type=frontier_request:1:DEFAULT&encoding=BLOBzip&p1=eNoly8EKwjAMANBfyW03/8BDndEV26akdeIphK0DoTJw3f8reH8vocM.Q0/u7oME4xEuTB7Y5GBvNB4ikRNi8SZGG67ylwkeAzLCiJwshWOne1vf2l6TzGXRvTZZ1o8Mk9ZY5rI1rVsHxGdkOD0hUrL5976NEifp


Query started:  01/03/07 16:42:44
Query ended:  01/03/07 16:42:44
Query time: 0.0153760910034 [seconds]

Query result:
&lt;?xml version="1.0" encoding="US-ASCII"?&gt;
&lt;!DOCTYPE frontier SYSTEM "http://frontier.fnal.gov/frontier.dtd"&gt;
&lt;frontier version="3.4" xmlversion="1.0"&gt;
 &lt;transaction payloads="1"&gt;
  &lt;payload type="frontier_request" version="1" encoding="BLOBzip"&gt;
   &lt;data&gt;eJxjY2Bg4Hb29wn19Yv3c/R1ZQPyOcIcg5w9HIOM2EE8Jk8XMM0c4B+MyhD39Qxx9Q2O93B29Alw
dXENDnH0ifeFKpfGKhnm6BPqakRIgQlYAbtvsH9QiCtB44wJKTAEK2D1dImHug3KBAABPDT5&lt;/data&gt;
   &lt;quality error="0" md5="a573175c652667ec4b47fa4f3dba6040" records="11" full_size="252"/&gt;
  &lt;/payload&gt; &lt;/transaction&gt;
&lt;/frontier&gt;


Fields:
     COLUMN_NAME     VARCHAR2

Records:
     ID
     POS
     POS
     MITEMS_HCALPEDESTAL_MID
     MITEMS_HCALPEDESTAL_MVALUE2
     MITEMS_HCALPEDESTAL_MVALUE4

MSORTED
     MITEMS_HCALPEDESTAL_MVALUE3
     MITEMS_HCALPEDESTAL_MVALUE1
     ID_ID
     ID_ID
$

</pre>

</ul>


<hr>
<address><a href="mailto:dwd@fnal.gov">Dave Dykstra</a></address>
<!-- hhmts star -->
Last modified: 4 January 2007
<!-- hhmts end -->
  </body>
</html>
